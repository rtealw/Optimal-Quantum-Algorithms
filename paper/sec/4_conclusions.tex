\section{Changes to Scope}

The most obvious next step is to
speed up our SDP solver.
The slowest part of our implementation is the
process of decomposing a very large matrix at
each iteration.
While we will always need to implement
such a computationally expensive step,
we may save space and time by optimizing other 
components of our implementation.
We could increase the efficiency that
we store our matrices or otherwise 
decrease the computational work done at each step.
However, even in the best case where
we double or triple the speed of our implementation,
we are hitting the exponential size of the SDP.
A scalar improvement will not make a meaningful
difference in our ability to solve different sizes
of SDP.
Right now, we can solve SDPs on all bit strings
of length 4 or maybe 5 in reasonable time
but we will not be able to reasonably solve
SDPs with all 6 or 7 bit strings no matter the extent
to which we optimize our implementation.

Computationally we cannot make much progress.
But if we can limit the inputs to our SDP,
only considering the worst-case bit strings
of the Boolean function,
we can decrease the size of our SDP problem
and therefore the time it takes to solve.
As demonstrated in \cref{sec:speed}, 
the strategy of considering only the worst-case
inputs substantially improves the speed of solving the SDP.
One way we can limit the Boolean inputs is from
insights about the Boolean function.
We have demonstrated this approach in perhaps the most
trivial case with OR.
We can extend this strategy by considering additional
Boolean functions.
The other, more general way we can limit the number
of Boolean inputs is by optimizing our SDP solver.
Perhaps within a few iterations, we can tell
that certain inputs take relatively few queries to find
the output.
By optimizing as we go, we can apply our strategy to
an Boolean function while simultaneously cutting down
the time run time of solving it.

Another direction for our work is to implement
a distinct but related problem.
Our SDP solver solves the primal:
finding the optimal quantum query complexity
of arbitrary Boolean functions)
There also exists a dual SDP whose solution 
corresponds to the optimal quantum algorithm itself.
We can implement the dual of our current problem
and, in addition to finding the query complexity,
also find the algorithm itself.



\begin{acks}
The authors would like to thank Professors Shelby Kimmel
and Philip Caplan for their invaluable help and support. 
\end{acks}