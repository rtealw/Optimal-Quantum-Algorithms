\section{Introduction}

We consider Boolean functions whose inputs
are a binary string and whose outputs are a single bit.
For example, let $f$ be the "or" function.
Then $f$ takes as input $x \in \{0,1\}^n$ and outputs
0 if $x$ contains no 1's and 0 otherwise.
The semi-definite program we plan to implement
takes a Boolean function--all $2^n$ inputs and outputs--
and returns the least number of queries a quantum
algorithm would need to solve the function.
An algorithm performs a query every time it checks the value
of an input.
For example, a classical algorithm would need to check every
bit in $x$ before concluding that no 1's are present.
However, a quantum algorithm may use Grover's search
to find a 1 in $\sqrt{n}$ queries.

We store our coding implementation and work at
\url{https://github.com/rtealw/Optimal-Quantum-Algorithms}.

\cite{beigi2018span} provide an excellent introduction to SDPs
and explain the relationship between SDPs and quantum query complexity.
\cite{reichardt2009span} gives an alternate formulation of the SDP
we will be working with.
\cite{boyd2004convex} is the authoritative text on convex optimization
and semi-definite programming.
The first steps of our work include reformulating the SDP in terms
of more standard convex optimization algorithms and then implementing
our algorithm.
Given the exponential nature of the storage and computation of the
SDP, we hope to exploit some structure in the problem.

It has been shown that obtaining optimal bounds of
quantum query complexity can be reformulated as a
semidefinite programming problem. However, it seems that
the literature is still lacking and implementation of an
SDP solver that leverages the unique structure found in
these problems. We hope to improve on existing approaches
to solving these convex optimization problems while
creating a more thorough understanding of these
algorithms.