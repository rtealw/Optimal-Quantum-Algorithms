\section{Introduction}

Quantum computers have the potential to 
solve computationally difficult problems
faster and more efficiently than classical computers.
Since sufficiently large quantum computers do not yet exist,
we cannot compare the time it takes a quantum computer
to run an algorithm to the time it takes a classical computer
to run an equivalent algorithm.
Instead we rely on asymptotic run time that 
characterizes the time an algorithm will take in relation
to the size of the input.
In the study of quantum algorithms, it is often easier
and more elegant to describe an algorithm's query complexity.
Imagine a model where an algorithm is given access
to an input as a string of bits.
The query complexity of an algorithm is then the number
of bits the algorithm needs to reveal to determine a solution.
Query complexity is a lower bound for run time
(each query takes one time step);
however, run time can asymptotically outpace query complexity.

Consider the Boolean function OR.
An algorithm for the OR function returns 0 if
there are only 0's in the input string
and 1 if there are any 1's in the input string.
Classically, an algorithm must check that
every single bit of the input is a 0.
Then if there are $n$ bits in the input string
the classical algorithm's query complexity is $n$.
However, the quantum algorithm Grover's search
can solve the function OR in $\sqrt{n}$ queries \cite{grover1996fast}.

In the study of quantum algorithms,
we call the query complexity of the most efficient quantum
algorithm optimal.
Then when comparing quantum and classical algorithms,
we can say that the quantum algorithm is more
efficient than the classical algorithm in the sense
that the optimal quantum query complexity
is lower than the optimal classical query complexity.

Lee et al. show that optimal quantum query complexity
corresponds to the solution of a semidefinite program (SDP)
\cite{lee2011quantum}.
Reichardt reformulates the SDP into a more simple description 
\cite{reichardt2009span}.
We take Reichardt's formulation and convert it
to a standard definition found in Boyd \cite{boyd2004convex}.
We then implement an SDP solver to find the
quantum query complexity of arbitrary Boolean functions.
(While the SDP can solve any function,
we limit our scope to Boolean functions with
binary inputs and outputs).

CVXOPT and SDPA are both popular, existing convex optimization
libraries in Python \cite{cvxopt, SDPA}.
However, neither libraries easily support the standard form
of the SDP problem we are solving.
We instead turn to an alternating direction method (ADM).
Wen et al.'s algorithm efficiently exploits the 
sparsity of our SDP \cite{adm}.

Our goal is to create a tool that takes as input a 
natural number $n$ and a Boolean function 
$f: \{0,1\}^n \rightarrow \{0,1\}$. 
By solving Reichardt's SDP problem with
Wen et al.'s ADM algorithm,
we return the optimal quantum query complexity of
$f$. We hope that quantum algorithm researchers use
our tool to discover and verify optimal quantum
algorithms.