\section{Background}

\subsection{The Problem}
Given an input Boolean function $f$, and a natural number $n$, 
calculate the optimal quantum query complexity of $f$ on bit 
strings of length $n$ which is the number of queries required to 
evaluate $f$ on the worst case input of length $n$. Then, use 
this result to produce the query
optimal span program that evaluates $f$ on inputs of length $n$. 
Note that we calculate the quantum query complexity and not the 
number of queries as our technique has been show to be accurate 
to some constant factor for all values of $n$ 
\cite{reichardt2009span}.

The closed form calculation for the optimal quantum query 
complexity of a given Boolean function has been previously 
derived as the solution to a semidefinite programming (SDP) 
problem \cite{childs} \cite{reichardt2009span}. However, we have 
not found an SDP solver for which we can easily formulate this 
problem and get our solution. Therefore, we implemented an 
existing SDP solving algorithm \cite{adm} and specifically geared
our implementation to the problem of query optimal quantum 
algorithms for Boolean functions.

We take as an input a Boolean function $f$ and number $n$, and 
formulate the semidefinite program where the solution is the 
optimal quantum query complexity. We use the SDP solving 
algorithm shown in \cite{adm} and then return the objective 
function value of the optimization as the optimal quantum query 
complexity. We also make use of the matrix solution to the SDP to
derive the span program that implements the query optimal 
algorithm for evaluating $f$.

\subsection{Semidefinite Programming and Quantum Algorithms}


Reichardt states the optimal quantum query complexity with the following SDP problem \cite{reichardt2009span}. (Note that $[n]$ denotes the array
$[1,2,...,n]$.)
Let $S^n$ be the set of symmetric matrices of size $n \times n$.
Then quantum query complexity of $f$ is
\begin{align} \label{Eq:reichardt_obj} 
    \min_{\X \in S^n} \max_{y \in D} \sum_{j \in [n]} \bra{y,j}\X\ket{y,j} 
\end{align}
such that $\X \succeq 0$ (semidefinite)
and for ordered pairs ($y$,$z$) such that $f(y) \neq f(z)$,
\begin{align}\label{Eq:reichardt_F0}
    \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1.
\end{align}

However, SDP's are usually described using their standard form, shown below \cite{boyd2004convex}. Given $C$, $A^{(i)} \in S^n$ for $i \in \{1,\dots,m\}$, and $b \in \R^n$
the standard form of $\X$ is:
\begin{align} \label{Eq:standard}
    \min_{X \in S^n} \tr (C, \X) \textrm{ s.t. }
    \A(X) = b, X \succeq 0
\end{align}
where the linear map $\A: S^n \rightarrow \R^m$ is defined as
\begin{align}
    \A(\X) := \left( \tr(A^{(1)} \X), \dots, \tr(A^{(m)} \X) \right)^T
    \nonumber
\end{align}

As a result, many of the existing SDP solvers we looked at used some variation of this form and we found it difficult to convert Reichardt's SDP into the correct input form.


\subsection{Quantum Query Complexity}

Note that in Eq. \ref{Eq:reichardt_obj} we are finding the 
$\Xb$ that minimizes the objective function. Here 
the objective function is the the maximum over input strings 
of the sum over bits of the input string. 
Therefore the optimal objective function value 
(optimal quantum query complexity) can be considered to 
be the optimal quantum query complexity on the worst-case input. 
Intuitively, this is in line with our adversarial model of 
query complexity where our algorithm is only as good 
as its worst-case query complexity. As a note, if we knew the worst case inputs in advance, we could drastically simplify the problem. Although this is not the case in general, we later show the efficacy of such an approach using the search function.

\subsection{Span Programs}
A span program is a way of evaluating a Boolean function. It consists of some set of vectors $V$ in $\mathbb{R}^n$ for some $n$. It also consists of a target vector $\tau$. Given an input string, we obtain $V_{\text{avail}} \subseteq{V}$ which is a set of the columns of $V$. If there exists some vector $x$ such that $V_{\text{avail}} x = \tau$ we return true and otherwise we return false. Thus to define a span program for some function $f$, we must define a set of vectors $V$, a rule for selecting a subset of $V$ given an input, and a target vector $\tau$.


\begin{comment}

In addition to the optimal quantum query complexity,
the solution to \cref{Eq:reichardt_F0} specifies
a span program provided $f$ is Boolean (rather than
partially Boolean) \cite{reichardt2009span}.

In order to transform $\X$ into a span program that
evaluates $f$, we construct a set of vectors
$\bra{v_{y,i}}$ for all $y \in D$ where $i = [n]$.
Given any two input strings $y, z \in D$ such that $y\neq z$,
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} = 1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
where $\delta_{f(y), f(z)} = 1$ if $f(y) = f(z)$ and $0$ otherwise.

Recall from \cref{Eq:reichardt_F0} that $\X$ satisfies
\begin{align}
    \forall (y,z) \in F \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1 \nonumber.
\end{align}
We would like to construct $\bra{v_{y,i}}$ and $\ket{v_{z,i}}$
from $\X$.
So we define a matrix $L$ such that $L^\dagger L = \X$.
Then $\bra{v_{y,i}} = \bra{y_i}L^\dagger$.
We can now reformulate the requirement of vectors $\bra{v_{y,i}}$
as
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} &= \sum_{i: y_i \ne z_i}
    \bra{y,i} L^\dagger L \ket{z, i} \nonumber \\
    &= \sum_{i: y_i \ne z_i} \bra{y,i} \X \ket{z, i} = 
    1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
Given the set of vectors $\bra{v_{y,i}}$ for all $y \in
D$, $i \in [n]$, we construct 
matrix $I$ that contains the vectors for the span
program. We will make use of the sets $F_i =
\{y \in D: f(y) = i\}$.
(Note that $F_i[k]$ denotes the $k^{th}$ element of $F_i$.)

\begin{align}\label{input_vectors}
    I = \sum_{k \in [|F_0|], j \in [n], y = F_0[k]}
    \ket{k}\bra{j, \overline{y_j}} \bra{v_{y,j}}
    \nonumber
\end{align}

$I$ is divided into sub-matrices that
correspond to different bits in the input to the
algorithm.
The columns of $I$ are evenly divided into
$n$ chunks corresponding to each input bit.
Each of these sub-matrices is further evenly divided into a left and
right sub-matrix, corresponding to a $0$ or $1$
in the relevant bit of the input.
Let $I(y)$ be the set of columns in 
$I$ that are available on input $y \in D$.
The target vector $\tau$ 
is a vector of ones vector with the same 
dimension as $I$.
The output is true if and only if the available
vectors $I(y)$ span to $\tau$.
Then, when evaluated on a quantum computer,
the query complexity of $I$ evaluating $f$ matches
the optimal quantum query complexity of $f$
\cite{reichardt2009span}.


















The closed form calculation of the optimal quantum query complexity for a given function has been derived previously \cite{childs} \cite{reichardt2009span}. However, we have not found a suitable implementation to make these calculation and we have found that general purpose SDP solvers are not well equipped for this problem.

The focus of this research is to calculate the optimal quantum
query complexity of a given Boolean function, as well as
provide the query optimal quantum algorithm to evaluate the
Boolean function. As with algorithm design for any computer,
we are mainly worried about the run time on the worst-case
input. We use the query complexity of a quantum algorithm to
establish a lower bound on the run time as each query of the
input will take some amount of time.


Boolean functions
Consider a Boolean function $f$ such that
$f: D \rightarrow E$ where 
$D \subseteq {\{0,1\}}^n$ and $E \subseteq {\{0,1\}}$.

Query complexity is how many input bits we
need in the worst case to find $f(x)$

An algorithm evaluates $f$ and is query optimal
if it evaluates $f$ in the least number of queries


A span program is a linear-algebraic model of computation that
evaluates a Boolean function $f: D \rightarrow E$
where $D \subseteq \{0,1\}^n$ and $E = \{0,1\}$.
A span program consists of a set of
vectors such that on a given input $x$, the vectors are
partitioned into available and unavailable sets.
The available vectors are turned into the columns of a matrix $A$.
These vectors form a linear system $Ax = \tau$
for a fixed target vector $\tau$.
If this system is homogeneous (i.e. there exists
some non-trivial vector $x$ that satisfies the equation)
then the algorithm returns true.
Otherwise, the algorithm returns false.
That is, the available vectors "span" the target vector
iff $f(x) =1$.

\subsection{Semidefinite Programming and Quantum Algorithms}

Form of SDP (Reichardt)

Reichardt states the optimal quantum query complexity with the
following SDP formulation \cite{reichardt2009span}.
(Note that $[n]$ denotes the array
$[1,2,...,n]$.)
Let $S^n$ be the set of symmetric matrices of size $n \times n$.
Then quantum query complexity of $f$ is
\begin{align} \label{Eq:reichardt_obj} 
    \min_{\X \in S^n} \max_{y \in D} \sum_{j \in [n]} \bra{y,j}\X\ket{y,j} 
\end{align}
such that $\X \succeq 0$ (semidefinite)
and for ordered pairs ($y$,$z$) such that $f(y) \neq f(z)$,
\begin{align}\label{Eq:reichardt_F0}
    \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1.
\end{align}

Form of SDP (Original)

In order to find such an $\X$, we convert the problem to standard
form.

Given $C$, $A^{(i)} \in S^n$ for $i \in \{1,\dots,m\}$, and $b \in \R^n$
the standard form of $\X$ is
\begin{align} \label{Eq:standard}
    \min_{X \in S^n} \tr (C, \X) \textrm{ s.t. }
    \A(X) = b, X \succeq 0
\end{align}
where the linear map $\A: S^n \rightarrow \R^m$ is defined as
\begin{align}
    \A(\X) := \left( \tr(A^{(1)}, \X), \dots, \tr(A^{(m)}, \X) \right)^T
    \nonumber
\end{align}

The main improvement our code provides over existing libraries is the ability 
to easily input a function and have Reichardt's formulation converted into a standard 
form and solved. We have further optimized our code to exploit the 
structure of this conversion to quickly move to solving the SDP.


\subsubsection{Quantum Query Complexity}

Note that in Eq. \ref{Eq:reichardt_obj} we are finding the 
$\Xb$ that minimizes the objective function. Here 
the objective function is the the maximum over input strings 
of the sum over bits of the input string. 
Therefore the optimal objective function value 
(optimal quantum query complexity) can be considered to 
be the optimal quantum query complexity on the worst-case input. 
Intuitively, this is in line with our adversarial model of 
query complexity where our algorithm is only as good 
as its worst-case query complexity.

Lower right hand value

Prepare the reader for worst case inputs

\subsubsection{Span Programs}
In addition to the optimal quantum query complexity,
the solution to \cref{Eq:reichardt_F0} specifies
a span program provided $f$ is Boolean (rather than
partially Boolean) \cite{reichardt2009span}.

In order to transform $\X$ into a span program that
evaluates $f$, we construct a set of vectors
$\bra{v_{y,i}}$ for all $y \in D$ where $i = [n]$.
Given any two input strings $y, z \in D$ such that $y\neq z$,
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} = 1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
where $\delta_{f(y), f(z)} = 1$ if $f(y) = f(z)$ and $0$ otherwise.

Recall from \cref{Eq:reichardt_F0} that $\X$ satisfies
\begin{align}
    \forall (y,z) \in F \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1 \nonumber.
\end{align}
We would like to construct $\bra{v_{y,i}}$ and $\ket{v_{z,i}}$
from $\X$.
So we define a matrix $L$ such that $L^\dagger L = \X$.
Then $\bra{v_{y,i}} = \bra{y_i}L^\dagger$.
We can now reformulate the requirement of vectors $\bra{v_{y,i}}$
as
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} &= \sum_{i: y_i \ne z_i}
    \bra{y,i} L^\dagger L \ket{z, i} \nonumber \\
    &= \sum_{i: y_i \ne z_i} \bra{y,i} \X \ket{z, i} = 
    1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
Given the set of vectors $\bra{v_{y,i}}$ for all $y \in
D$, $i \in [n]$, we construct 
matrix $I$ that contains the vectors for the span
program. We will make use of the sets $F_i =
\{y \in D: f(y) = i\}$.
(Note that $F_i[k]$ denotes the $k^{th}$ element of $F_i$.)

\begin{align}\label{input_vectors}
    I = \sum_{k \in [|F_0|], j \in [n], y = F_0[k]}
    \ket{k}\bra{j, \overline{y_j}} \bra{v_{y,j}}
    \nonumber
\end{align}

$I$ is divided into sub-matrices that
correspond to different bits in the input to the
algorithm.
The columns of $I$ are evenly divided into
$n$ chunks corresponding to each input bit.
Each of these sub-matrices is further evenly divided into a left and
right sub-matrix, corresponding to a $0$ or $1$
in the relevant bit of the input.
Let $I(y)$ be the set of columns in 
$I$ that are available on input $y \in D$.
The target vector $\tau$ 
is a vector of ones vector with the same 
dimension as $I$.
The output is true if and only if the available
vectors $I(y)$ span to $\tau$.
Then, when evaluated on a quantum computer,
the query complexity of $I$ evaluating $f$ matches
the optimal quantum query complexity of $f$
\cite{reichardt2009span}.

\subsection{SDP Algorithm}

We use the alternating direction method of multipliers (ADMM)
described by \cite{adm} to find an $\X$ that satisfies
\cref{Eq:reichardt_obj}.
ADMM is a variant
of the more general method of multipliers (also known
as the augmented Lagrangian method).
The method of multipliers solves a constrained optimization
problem by turning it into a series of unconstrained optimization
problems and adding both a penalty and Lagrange multiplier 
to the objective function.
The difference between ADMM and the method of multipliers
is that ADMM updates the dual variables during each iteration.
The particular ADMM we use takes advantage of the constraint sparsity
and orthogonality in \cref{Eq:reichardt_F0} \cite{adm}.

The pseudocode of the ADMM algorithm appears below.
\begin{figure}[h]
\begin{algorithm2e}[H]
    \SetAlgoLined
    Set $\X_0 \succeq 0$ and $S_0 \succeq 0$ \\
    \For{k = 0,\dots}{
        Compute $y_{k+1}$ \\
        Compute $V_{k+1}$ \\
        Compute $S_{k+1}$ \\
        Compute $\X_{k+1} = \frac{1}{\mu}(S_{k+1} - V_{k+1})$ \\
    }
    \caption{Alternating Direction Method of Multipliers
    \cite{adm}}
\end{algorithm2e}
\end{figure}

The algorithm may halt either after a fixed number of
iterations or after the change in the objective value
between two iterations drops below a set value.

Define $y_{k+1}$ as
\begin{align}
    -(\A \A^*)^{-1} (\mu (\A(X) - b) + \A(S-C))
    \nonumber
\end{align}
where the adjoint operator $\A^*:\R^m \rightarrow S^n$ is
\begin{align}
    \A^* := \sum_{i=1}^m y_i A^{(i)} = A^T y.
    \nonumber
\end{align}
Note that we use the Moore-Penrose pseudoinverse.

Define $V_{k+1}$ as
\begin{align}
    V_{k+1} := C - \A^*(y_{k+1}) - \mu X.
    \nonumber
\end{align}

Define $S_{k+1}$ as $Q_\dagger \sum_+ Q_\dagger^T$
where $Q \sum Q^T$ is the spectral decomposition
of $V_{k+1}$ and $\sum_+$ denotes the non-negative eigenvalues.

Finally, define $\X_{k+1}$ as
\begin{align}
    \X_{k+1} := \frac{1}{\mu}(S_{k+1} - V_{k+1}).
    \nonumber
\end{align}

Then, after sufficient iterations in the ADMM algorithm,
$\X$ will be arbitrarily close to the solution
of the standard form of the SDP.
\end{comment}