\section{Implementation}

We implemented a user friendly way to define a Boolean function and 


In addition to the optimal quantum query complexity,
the solution to \cref{Eq:reichardt_F0} specifies
a span program provided $f$ is Boolean (rather than
partially Boolean) \cite{reichardt2009span}.

In order to transform $\X$ into a span program that
evaluates $f$, we construct a set of vectors
$\bra{v_{y,i}}$ for all $y \in D$ where $i = [n]$.
Given any two input strings $y, z \in D$ such that $y\neq z$,
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} = 1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
where $\delta_{f(y), f(z)} = 1$ if $f(y) = f(z)$ and $0$ otherwise.

Recall from \cref{Eq:reichardt_F0} that $\X$ satisfies
\begin{align}
    \forall (y,z) \in F \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1 \nonumber.
\end{align}
We would like to construct $\bra{v_{y,i}}$ and $\ket{v_{z,i}}$
from $\X$.
So we define a matrix $L$ such that $L^\dagger L = \X$.
Then $\bra{v_{y,i}} = \bra{y_i}L^\dagger$.
We can now reformulate the requirement of vectors $\bra{v_{y,i}}$
as
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} &= \sum_{i: y_i \ne z_i}
    \bra{y,i} L^\dagger L \ket{z, i} \nonumber \\
    &= \sum_{i: y_i \ne z_i} \bra{y,i} \X \ket{z, i} = 
    1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
Given the set of vectors $\bra{v_{y,i}}$ for all $y \in
D$, $i \in [n]$, we construct 
matrix $I$ that contains the vectors for the span
program. We will make use of the sets $F_i =
\{y \in D: f(y) = i\}$.
(Note that $F_i[k]$ denotes the $k^{th}$ element of $F_i$.)

\begin{align}\label{input_vectors}
    I = \sum_{k \in [|F_0|], j \in [n], y = F_0[k]}
    \ket{k}\bra{j, \overline{y_j}} \bra{v_{y,j}}
    \nonumber
\end{align}

$I$ is divided into sub-matrices that
correspond to different bits in the input to the
algorithm.
The columns of $I$ are evenly divided into
$n$ chunks corresponding to each input bit.
Each of these sub-matrices is further evenly divided into a left and
right sub-matrix, corresponding to a $0$ or $1$
in the relevant bit of the input.
Let $I(y)$ be the set of columns in 
$I$ that are available on input $y \in D$.
The target vector $\tau$ 
is a vector of ones vector with the same 
dimension as $I$.
The output is true if and only if the available
vectors $I(y)$ span to $\tau$.
Then, when evaluated on a quantum computer,
the query complexity of $I$ evaluating $f$ matches
the optimal quantum query complexity of $f$
\cite{reichardt2009span}.
















\begin{comment}

The closed form calculation of the optimal quantum query complexity for a given function has been derived previously \cite{childs} \cite{reichardt2009span}. However, we have not found a suitable implementation to make these calculation and we have found that general purpose SDP solvers are not well equipped for this problem.

The focus of this research is to calculate the optimal quantum
query complexity of a given Boolean function, as well as
provide the query optimal quantum algorithm to evaluate the
Boolean function. As with algorithm design for any computer,
we are mainly worried about the run time on the worst-case
input. We use the query complexity of a quantum algorithm to
establish a lower bound on the run time as each query of the
input will take some amount of time.


Boolean functions
Consider a Boolean function $f$ such that
$f: D \rightarrow E$ where 
$D \subseteq {\{0,1\}}^n$ and $E \subseteq {\{0,1\}}$.

Query complexity is how many input bits we
need in the worst case to find $f(x)$

An algorithm evaluates $f$ and is query optimal
if it evaluates $f$ in the least number of queries
\end{comment}

A span program is a linear-algebraic model of computation that
evaluates a Boolean function $f: D \rightarrow E$
where $D \subseteq \{0,1\}^n$ and $E = \{0,1\}$.
A span program consists of a set of
vectors such that on a given input $x$, the vectors are
partitioned into available and unavailable sets.
The available vectors are turned into the columns of a matrix $A$.
These vectors form a linear system $Ax = \tau$
for a fixed target vector $\tau$.
If this system is homogeneous (i.e. there exists
some non-trivial vector $x$ that satisfies the equation)
then the algorithm returns true.
Otherwise, the algorithm returns false.
That is, the available vectors "span" the target vector
iff $f(x) =1$.

\subsection{Semidefinite Programming and Quantum Algorithms}

Form of SDP (Reichardt)

Reichardt states the optimal quantum query complexity with the
following SDP formulation \cite{reichardt2009span}.
(Note that $[n]$ denotes the array
$[1,2,...,n]$.)
Let $S^n$ be the set of symmetric matrices of size $n \times n$.
Then quantum query complexity of $f$ is
\begin{align} \label{Eq:reichardt_obj} 
    \min_{\X \in S^n} \max_{y \in D} \sum_{j \in [n]} \bra{y,j}\X\ket{y,j} 
\end{align}
such that $\X \succeq 0$ (semidefinite)
and for ordered pairs ($y$,$z$) such that $f(y) \neq f(z)$,
\begin{align}\label{Eq:reichardt_F0}
    \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1.
\end{align}

Form of SDP (Original)

In order to find such an $\X$, we convert the problem to standard
form.

Given $C$, $A^{(i)} \in S^n$ for $i \in \{1,\dots,m\}$, and $b \in \R^n$
the standard form of $\X$ is
\begin{align} \label{Eq:standard}
    \min_{X \in S^n} \tr (C, \X) \textrm{ s.t. }
    \A(X) = b, X \succeq 0
\end{align}
where the linear map $\A: S^n \rightarrow \R^m$ is defined as
\begin{align}
    \A(\X) := \left( \tr(A^{(1)}, \X), \dots, \tr(A^{(m)}, \X) \right)^T
    \nonumber
\end{align}

The main improvement our code provides over existing libraries is the ability 
to easily input a function and have Reichardt's formulation converted into a standard 
form and solved. We have further optimized our code to exploit the 
structure of this conversion to quickly move to solving the SDP.


\subsubsection{Quantum Query Complexity}

Note that in Eq. \ref{Eq:reichardt_obj} we are finding the 
$\Xb$ that minimizes the objective function. Here 
the objective function is the the maximum over input strings 
of the sum over bits of the input string. 
Therefore the optimal objective function value 
(optimal quantum query complexity) can be considered to 
be the optimal quantum query complexity on the worst-case input. 
Intuitively, this is in line with our adversarial model of 
query complexity where our algorithm is only as good 
as its worst-case query complexity.

Lower right hand value

Prepare the reader for worst case inputs

\subsubsection{Span Programs}
In addition to the optimal quantum query complexity,
the solution to \cref{Eq:reichardt_F0} specifies
a span program provided $f$ is Boolean (rather than
partially Boolean) \cite{reichardt2009span}.

In order to transform $\X$ into a span program that
evaluates $f$, we construct a set of vectors
$\bra{v_{y,i}}$ for all $y \in D$ where $i = [n]$.
Given any two input strings $y, z \in D$ such that $y\neq z$,
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} = 1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
where $\delta_{f(y), f(z)} = 1$ if $f(y) = f(z)$ and $0$ otherwise.

Recall from \cref{Eq:reichardt_F0} that $\X$ satisfies
\begin{align}
    \forall (y,z) \in F \sum_{j \in [n]: y_j \ne z_j} 
    \bra{y,j} \X \ket{z, j} = 1 \nonumber.
\end{align}
We would like to construct $\bra{v_{y,i}}$ and $\ket{v_{z,i}}$
from $\X$.
So we define a matrix $L$ such that $L^\dagger L = \X$.
Then $\bra{v_{y,i}} = \bra{y_i}L^\dagger$.
We can now reformulate the requirement of vectors $\bra{v_{y,i}}$
as
\begin{align}
    \sum_{i: y_i \ne z_i} \braket{v_{y,i}|v_{z,i}} &= \sum_{i: y_i \ne z_i}
    \bra{y,i} L^\dagger L \ket{z, i} \nonumber \\
    &= \sum_{i: y_i \ne z_i} \bra{y,i} \X \ket{z, i} = 
    1 - \delta_{f(y), f(z)}
    \nonumber
\end{align}
Given the set of vectors $\bra{v_{y,i}}$ for all $y \in
D$, $i \in [n]$, we construct 
matrix $I$ that contains the vectors for the span
program. We will make use of the sets $F_i =
\{y \in D: f(y) = i\}$.
(Note that $F_i[k]$ denotes the $k^{th}$ element of $F_i$.)

\begin{align}\label{input_vectors}
    I = \sum_{k \in [|F_0|], j \in [n], y = F_0[k]}
    \ket{k}\bra{j, \overline{y_j}} \bra{v_{y,j}}
    \nonumber
\end{align}

$I$ is divided into sub-matrices that
correspond to different bits in the input to the
algorithm.
The columns of $I$ are evenly divided into
$n$ chunks corresponding to each input bit.
Each of these sub-matrices is further evenly divided into a left and
right sub-matrix, corresponding to a $0$ or $1$
in the relevant bit of the input.
Let $I(y)$ be the set of columns in 
$I$ that are available on input $y \in D$.
The target vector $\tau$ 
is a vector of ones vector with the same 
dimension as $I$.
The output is true if and only if the available
vectors $I(y)$ span to $\tau$.
Then, when evaluated on a quantum computer,
the query complexity of $I$ evaluating $f$ matches
the optimal quantum query complexity of $f$
\cite{reichardt2009span}.

\subsection{SDP Algorithm}

We use the alternating direction method of multipliers (ADMM)
described by \cite{adm} to find an $\X$ that satisfies
\cref{Eq:reichardt_obj}.
ADMM is a variant
of the more general method of multipliers (also known
as the augmented Lagrangian method).
The method of multipliers solves a constrained optimization
problem by turning it into a series of unconstrained optimization
problems and adding both a penalty and Lagrange multiplier 
to the objective function.
The difference between ADMM and the method of multipliers
is that ADMM updates the dual variables during each iteration.
The particular ADMM we use takes advantage of the constraint sparsity
and orthogonality in \cref{Eq:reichardt_F0} \cite{adm}.

The pseudocode of the ADMM algorithm appears below.
\begin{figure}[h]
\begin{algorithm2e}[H]
    \SetAlgoLined
    Set $\X_0 \succeq 0$ and $S_0 \succeq 0$ \\
    \For{k = 0,\dots}{
        Compute $y_{k+1}$ \\
        Compute $V_{k+1}$ \\
        Compute $S_{k+1}$ \\
        Compute $\X_{k+1} = \frac{1}{\mu}(S_{k+1} - V_{k+1})$ \\
    }
    \caption{Alternating Direction Method of Multipliers
    \cite{adm}}
\end{algorithm2e}
\end{figure}

The algorithm may halt either after a fixed number of
iterations or after the change in the objective value
between two iterations drops below a set value.

Define $y_{k+1}$ as
\begin{align}
    -(\A \A^*)^{-1} (\mu (\A(X) - b) + \A(S-C))
    \nonumber
\end{align}
where the adjoint operator $\A^*:\R^m \rightarrow S^n$ is
\begin{align}
    \A^* := \sum_{i=1}^m y_i A^{(i)} = A^T y.
    \nonumber
\end{align}
Note that we use the Moore-Penrose pseudoinverse.

Define $V_{k+1}$ as
\begin{align}
    V_{k+1} := C - \A^*(y_{k+1}) - \mu X.
    \nonumber
\end{align}

Define $S_{k+1}$ as $Q_\dagger \sum_+ Q_\dagger^T$
where $Q \sum Q^T$ is the spectral decomposition
of $V_{k+1}$ and $\sum_+$ denotes the non-negative eigenvalues.

Finally, define $\X_{k+1}$ as
\begin{align}
    \X_{k+1} := \frac{1}{\mu}(S_{k+1} - V_{k+1}).
    \nonumber
\end{align}

Then, after sufficient iterations in the ADMM algorithm,
$\X$ will be arbitrarily close to the solution
of the standard form of the SDP.
